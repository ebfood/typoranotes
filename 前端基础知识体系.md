 

# HTML/CSS

## HTML

### 如何理解HTML语义化

+ 让人更容易读懂, 增加可读性
+ 搜索引擎优化

### 块状元素 内联元素

inline: span img input button



## 盒模型

### 盒子模型宽度的计算

+ offsetWidth=(内容宽度+内边距+边框) 无外边距
+ border-box 向内缩

### margin纵向层叠

+ 相邻元素margin top bottom 重叠
+ 空白的p也有类似的效果, margin会重叠

### margin负数

+ margin-top/left 负数, 会拽着往前
+ margin-right 负数, 右侧元素左移, 本身不受影响
+ margin-bottom负数, 本身不变, 下方元素上移(侵入)



## BFC

### 是什么

块级格式化上下文, 一块独立的渲染区域,内部元素渲染不会影响边界以外的元素.

### 形成条件

+ float不是none
+ positon absolute or fixed
+ overflow 不是 visible
+ display是 flex或者inline-block

### BFC的作用

+ 利用BFC避免margin重叠。
+ 自适应两栏布局
+ 清除浮动



## float

### 圣杯布局和双飞翼布局

实现一个**两侧宽度固定，中间宽度自适应的三栏布局**。

+ 使用float
+ 中间栏width100%, 两侧用margin负值, 向中间内容横向重叠
+ 防止中间内容被覆盖, 
  圣杯在大容器给一个padding, 然后吧两个侧栏的position relative, 移走 
  双飞翼用margin, 侧栏只提供margin的负值就位, 中间栏给个margin.

### 手写clearfix

基本知识点：

1. div的高度由div内部的内容高度决定
2. float浮动后div脱离文档流

所以：当一个div内部嵌套的div浮动后，外部的div高度会塌陷。
解决方案, 给容器添加一个伪类, 让他来感知浮动元素, 清除浮动, 这样就会撑开容器.

```CSS
.clearfix:after{
	content: '';
	display: block;
	clear: both;
}
```



## flex

### 三点骰子问题

+ 主轴 justify-content: space-between;
+ 点点设置 align-self: center | flex-end;



## position

### absolute和relative分别依据什么定位?

+ relative依据自身定位
+ absolute依据最近一层的定位元素(absolute relative fixed body) 来定位

### 居中对齐的实现方式

+ 水平居中
  + inline: text-align
  + block: margin 0 auto;
  + absolute left:50% margin-left: -half;
+ 垂直居中
  + inline: line-height
  + absolute: 
    1. top 50%  margin-top
    2. top:50% left: 50% + transform: translate(-50%, -50%) 这个是CSS3
    3. top left bottom right=0 + margin: auto



## css图文样式

### line-height如何继承

+ 如果带单位, 继承就是具体数值
+ 如果是倍数, 那就继承下来倍数, 子元素自己的font-size乘倍数就是行高
+ (坑)如果是带%, 就会在父亲里面直接计算好具体数字, 再继承给子元素



## 响应式

### rem是什么

+ px绝对长度单位
+ em, 相对长度单位,相对于父亲
+ rem, 相对的, 相对于根元素的长度
  给html设置font_size, rem就的值就是font_size的倍数,  rem = 实际px / basefont

### 响应式的方案?

+ media-query, 根据不同屏幕设置根元素font-size
+ 长度全部都用rem

### vw/vh

+ vh网页视口高度的 1/100
  window.innerHeight = 100vh
+ vw视口宽度的1/100



# Javascript基础语法

## 变量类型与计算

### 值类型和引用类型

 引用类型：对象，数组， null，函数 

### typeof运算符

+ 识别所有值类型
+ 识别函数
+ 识别是否是引用类型(都显示object)

### 深拷贝

```javascript
function deepClone(obj = {}) {
  // 不是引用类型就直接返回, 注意null坑
  if (typeof obj !== 'object' || obj == null) {
    return obj
  }

  //是数组还是对象呢？
  let result
  obj instanceof Array ? result = [] : result = {}
  
  // 遍历，递归
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key])
    }
  }

  return result
}
```

### 类型转换的坑

+ 字符串+数字 = 字符串
+ 字符串+ true = 字符串
+ 100 == '100'  // true
+ 0 == '',  0 == false, false == '', null == undefined ,  双等号尽量会转换
+ 用双等号只有一个情形，== null <=> ===null || === undefined, 其余一律三等

### if语句与逻辑运算

truly变量： !!a === true
falsely变量：!!a === false
`0, NaN, '', null, undefined, false` , 是falsely变量， 其余都是truly

|| 返回第一个真值，&&返回第一个假值

```JavaScript
result = value1 || value2 || value3;  //寻找第一个真
result = value1 && value2 && value3; //寻找第一个假
```



## 原型和原型链

### 原型

+ 每个函数（class）都有显示原型prototype属性，值是个普通对象
+ 每个实例都有隐式原型` __proto__`属性，值是个普通对象
+ 实例的`__proto__` 指向它构造函数（class）的prototype属性

原型的执行规则式：

+ 现在自身的属性和方法寻找
+ 如果找不到就到 `__proto__` 里面去找

### 原型链

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的`prototype`，如果还没有找到就会再在构造函数的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

![这里写图片描述](https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图文引用https://blog.csdn.net/xiaoermingn/article/details/80745117

第二个例图：

![image-20210323233108518](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210323233108518.png)

### 类型判断

instanceof 判断 变量属于哪个class，是顺着原型链向上找，找那个类的prototype

### 题目

#### 手写一个简单jQuery，考虑插件和扩展性？

```JavaScript
class jQuery {
  // 构造器
  constructor(selector) {
    const result = document.querySelectorAll(selector)
    const length = result.length
    //构建array like
    for (let i = 0; i < length; i++) {
      this[i] = result[i]
    }
    this.length = length
    this.selector = selector
  }

  get(index) {
    return this[index]
  }

  each(fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i]
      fn(elem)
    }
  }

  // 事件绑定
  on(type, fn) {
    return this.each(elem => {
      elem.addEventListener(type, fn, false)
    })
  }
}

// 使用
let $p = new jQuery('p')
console.log($p)
console.log($p.get(1))
$p.each(elem => console.log(elem.nodeName)) // p p p
$p.on('click',()=>alert('clicked'))

// 考虑插件
jQuery.prototype.dialog = function(info){
  console.log(info)
}

//定义新的对象并继承自jquery实现jquery 的扩展性，也就是造轮子
class MyjQ extends jQuery {
  constructor(selector) {
    super(selector) //用于调用父对象上的函数
  }

  addFunc() {
    console.log('new func')
  }
}

m = new MyjQ('p')
m.dialog(1)
m.addFunc()
```



## 作用域和闭包

### 作用域和自由变量

+ 全局作用域，函数作用域，块级作用域。
+ 自由变量：当前作用域没有定义但是被使用了**的变量**，向上作用域一层一层依次寻找，直到被找到了，如果全局都没找到，就报错了。

### 闭包

+ 函数作为参数被传递
+ 函数作为返回值被返回

所有的自由变量会在函数定义的作用域依次向上寻找，不是在执行的地方

### this

来看阮一峰的博客：http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html

this的取值在函数执行的时候确认的，不是函数定义的时候确认的

+ 作为普通函数：window
+ call apply bind：参数1
+ 对象方法：当前对象，也就是点符号前面那个对象
+ class方法中：当前创建的实例
+ 箭头函数：本身没有this

### 题目

#### 手写bind函数？

```JavaScript
function func(...arg){
  console.log(this)
  console.log(arg)
}

Function.prototype.myBind = function (thisArg,...arg) {
  let self = this // 谁调用了mybind，this就是谁，这里就是func了
  console.log(self)
  return function (...arg2) {
    self.apply(thisArg, [...arg, ...arg2])
  }
}

func(1,2,2,3,4)
let f2 = func.myBind({a: 1},2, 3, 4)
f2(6,6,6)
```



#### 闭包场景举例？

+ 隐藏数据, 只提供api

  ```javascript
  function createCache() {
    let data = {}
    // 闭包
    return {
      set: function (key, value) {
        this.data[key] = value
      },
      get: function (key) {
        return this.data[key]
      }
    }
  }
  ```

  

## 异步

### 单线程和异步

+ js是单线程语言
+ JS和DOM渲染共用一个线程
+ 遇到等待，网络请求，定时请求，同步会阻塞代码执行，异步不会阻塞代码执行。

### 应用场景

+ 网络请求：ajax，图片加载
+ 定时任务：setTimeOut

### Promise

<img src="https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210324191450642.png" alt="image-20210324191450642" style="zoom: 33%;" />

+ 利用回调函数层层嵌套的代码格式，显然显得冗余又容易出错，这就被称为 “回调地狱” 或者“回调深渊”。
+ Promise，可以理解为一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。构造函数接收两个参数，resolve和reject，这两个参数都是函数，是引擎提供的。

#### 三种状态

+ pending：过程中
+ resolved：解决了
+ rejected：失败了

#### 状态的表现和变化

+ 状态的变化只能是pending->resolved  /  pending->rejected
+ 变化是不可逆的
+ pending状态，不会触发then和catch
+ fulfilled状态，会触发后续的then回调函数
+ rejected状态，会触发后续的catch回调函数
+ ps：很多教程里把resolved(已完成)等价于fullfilled(成功)状态,也有的Promise状态定型为resolved包含fullfilled和rejected两种状态。但是由于习惯写法，Promise中“成功”的回调函数的名字依然叫做resolve。

#### then和catch对状态的影响

+ then正常返回fulfilled状态的Promise，里面报错就返回rejected
+ catch正常也返回fulfilled，里面报错返回rejected

### event-loop

JS是单线程的，异步要基于回调来实现，even-loop就是异步回调的实现原理

![image-20210324225519899](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210324225519899.png)

+ 同步代码一行行的放在Call Stack中执行
+ 遇到异步，会先记录下来，等待时机（定时，网络请求）
+ 时机到了，就移动到Callback Queue
+ 如果Call Stack为空（同步代码执行完成）event-loop立即开始工作
+ event-loop轮询查找Callback Queue，如果里面有东西就将其移动到Call Stack中执行
+ event-loop接着继续查找Callback Queue

#### DOM事件和event loop

+ 异步（setTimeout，ajax等）使用回调，基于event loop
+ DOM事件也使用回调，基于event loop



### async/await

用同步的语法编写，彻底消灭回调函数

+ 执行async返回的是Promise对象
+ await相当于Promise.then
+ try catch用来捕获异常，替代了Promise.catch
+ await后面都是异步，在同步的代码执行完成了之后才会执行

### 微任务/宏任务

#### 定义

+ 宏任务：setTimeout， setInterval，ajax，DOM事件
+ 微任务：Promise async/await
+ 微任务执行的时机早于宏任务

#### event loop 和dom渲染

+ 每次Call Stack清空（同步任务执行完成）都是Dom重新渲染的机会
+ DOM如果改变了此时会重新渲染
+ 然后再去触发Event loop

### 题目

#### promise实现图片加载

```javascript
const url1 = 'https://aecpm.alicdn.com/simba/img/TB1JNHwKFXXXXafXVXXSutbFXXX.jpg',
url2 = 'https://aecpm.alicdn.com/simba/img/TB1j4LLKpXXXXcbaXXXSutbFXXX.jpg'

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = document.createElement('img')
    //设置回调
    img.onload= () => { resolve(img) }
    img.onerror= () => { reject(new Error('图片加载失败 '+ src)) }
    // 赋值，开始加载~
    img.src = src
  })
}
// 串行化的代码
loadImage(url1).then( img => {
  console.log(img.width)
  return img
}).then(img => {
  console.log(img.height)
  return loadImage(url2)
}).then(img => {
  console.log(img.width)
  return img
}).then(img => {
  console.log(img.height)
}).catch(es => {console.error(es)})
```

#### 关于then和catch的面试题

```javascript
Promise.resolve().then(() =>{
  console.log(1)
}).catch(() =>{
  console.log(2)
}).then(() =>{
  console.log(3)
})

Promise.resolve().then(() =>{
  console.log(1)
  throw new Error('error1')
}).catch(() =>{
  console.log(2)
}).then(() =>{
  console.log(3)
})

Promise.resolve().then(() =>{
  console.log(1)
  throw new Error('error1')
}).catch(() =>{ //返回fulfilled
  console.log(2)
}).catch(() =>{
  console.log(3)
})
```

#### 来康康有关于async和await执行顺序

```JavaScript
async function func1() {
  console.log(2)
  await func2()
  // 以下相当于异步回调callback
  console.log(5) //异步的第一步
  await func3()
  // 以下又一层异步回调嵌套
  console.log(7)
}
async function func2() {
  console.log(3)
}
async function func3() {
  console.log(6)  //第一层异步结束
}

console.log(1)
func1()
console.log(4) // 同步代码执行完成，event loop开始
```



## 模块化

# JS-Web-API



# 开发环境



# 运行环境



# HTTP协议





